//#define	 INITGUID
#include "stdafx.h"
#include "../Core/game.h"
#include "../Core/MainFrm.h"
#include "../Core/Resource.h"
#include <mmsystem.h>
#include <ddraw.h>
#include <direct.h>
#include <string.h>
#include "audio.h"
#include "gameutil.h"
#include "gamecore.h"
#include "Shlwapi.h"
#include "../Game/config.h"
#include "../Game/mygame.h"
#include <filesystem>
#include <experimental/filesystem> // Header file for pre-standard implementation
#include <comdef.h>

namespace game_framework {

	/////////////////////////////////////////////////////////////////////////////
	// CMovingBitmap: Moving Bitmap class
	// ?o?? class ?¢FG??¢FDi¢FDH??¢FX??????¡Ó?
	// ?n????o?????I¢FDs(?B¢FD?)???U?????O?A???O¢FDi¢FDH?¢FG???U?C???{???O?¢FX???PN??
	/////////////////////////////////////////////////////////////////////////////

	//! CMovingBitmap ???c?l
	/*! 
		¢FD?????¢FD??@???|¢FD?????????????¢FD??C
	*/
	CMovingBitmap::CMovingBitmap()
	{
		isBitmapLoaded = false;
	}

	//! ????o CMovingBitmap ??¢FD???????¢FX?????C
	/*!
		???n¢FD????J?????C
		\return ????¢FX?????A¢FDH?????¢FX?????C
	*/
	int CMovingBitmap::GetHeight()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before Height() is called !!!");
		return locations[frameIndex].bottom - locations[frameIndex].top;
	}

	//! ????o CMovingBitmap ??¢FD???¢FD??W???? x ?b?y?????C
	/*!
		???n¢FD????J?????C
		\return ????¢FD??W???? x ?b?y?????C
	*/
	int CMovingBitmap::GetLeft()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before Left() is called !!!");
		return locations[frameIndex].left;
	}

	//! ???????????P??C
	/*!
		?z?L???P??s?? `IDB_BITMAP` ?????????????????A??¢FDB?L?o?S?w?C?? `color`?C
		\param IDB_BITMAP ???????P??s??
		\param color ????L?o???C???]?w?]?¢FX `CLR_INVALID`?A¢FDi?¡ÓQ¢FD? `RGB(<R>, <G>, <B>`) ???]?m?C???^
	*/
	void CMovingBitmap::LoadBitmap(int IDB_BITMAP, COLORREF color)
	{
		CBitmap bitmap;
		BOOL rval = bitmap.LoadBitmap(IDB_BITMAP);
		GAME_ASSERT(rval, "Load bitmap failed !!! Please check bitmap ID (IDB_XXX).");
		BITMAP bitmapSize;
		bitmap.GetBitmap(&bitmapSize);
		
		InitializeRectByBITMAP(bitmapSize);

		surfaceID.push_back(CDDraw::RegisterBitmap(IDB_BITMAP, color));
		filterColor = color;
		isBitmapLoaded = true;
	}

	//! ???????????P??C
	/*!
		?z?L???????????| `filepath` ?????????????????A??¢FDB?L?o?S?w?C?? `color`?C
		\param filepath ???????????|
		\param color ????L?o???C???]?w?]?¢FX `CLR_INVALID`?A¢FDi?¡ÓQ¢FD? `RGB(<R>, <G>, <B>`) ???]?m?L?o?C???^
	*/
	void CMovingBitmap::LoadBitmap(char *filepath, COLORREF color)
	{
		HBITMAP hbitmap = (HBITMAP)LoadImage(NULL, filepath, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

		if (hbitmap == NULL) {
			char error_msg[300];
			sprintf(error_msg, "Loading bitmap	from file \"%s\" failed !!!", filepath);
			GAME_ASSERT(false, error_msg);
		}

		CBitmap *bmp = CBitmap::FromHandle(hbitmap); // memory will be deleted automatically
		BITMAP bitmapSize;
		bmp->GetBitmap(&bitmapSize);

		InitializeRectByBITMAP(bitmapSize);

		surfaceID.push_back(CDDraw::RegisterBitmap(filepath, color));
		imageFileName = string(filepath);
		filterColor = color;
		isBitmapLoaded = true;

		bmp->DeleteObject();
	}

	//! ???????????P??C
	/*!
		?z?L???????????|?¢FX `filepaths` ???????h???????A??¢FDB?L?o?S?w?C?? `color`?C
		\param filepaths ???????????|?¢FX
		\param color ????L?o???C???]?w?]?¢FX `CLR_INVALID`?A¢FDi?¡ÓQ¢FD? `RGB(<R>, <G>, <B>`) ???]?m?L?o?C???^
		\sa https://en.cppreference.com/w/cpp/container/vector
	*/
	void CMovingBitmap::LoadBitmap(vector<char*> filepaths, COLORREF color)
	{
		for (int i = 0; i < (int)filepaths.size(); i++) {
			LoadBitmap(filepaths[i], color);
		}
	}

	//! ???????????P??C
	/*!
		?z?L???????????|?¢FX `filepaths` ???????h???????A??¢FDB?L?o?S?w?C?? `color`?C
		\param filepaths ???????????|?¢FX
		\param color ????L?o???C???]?w?]?¢FX `CLR_INVALID`?A¢FDi?¡ÓQ¢FD? `RGB(<R>, <G>, <B>`) ???]?m?L?o?C???^
		\sa https://en.cppreference.com/w/cpp/container/vector
	*/
	void CMovingBitmap::LoadBitmapByString(vector<string> filepaths, COLORREF color)
	{

		for (int i = 0; i < (int)filepaths.size(); i++) {
			LoadBitmap((char*)filepaths[i].c_str(), color);
		}
	}
	
	//! ??????¢FD????????P??C
	/*!
		?????@???S?w?j?p??¢FD????I¢FX}???C
		\param height ?????????
		\param width ?????e???
	*/
	void CMovingBitmap::LoadEmptyBitmap(int height, int width) {
		HBITMAP hbitmap = CreateBitmap(width, height, 1, 32, NULL);
		CBitmap *bmp = CBitmap::FromHandle(hbitmap); // memory will be deleted automatically

		/* Fill white color to bitmap */
		HDC hdc = CreateCompatibleDC(NULL);
		HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdc, hbitmap);
		PatBlt(hdc, 0, 0, width, height, WHITENESS);
		SelectObject(hdc, hOldBitmap);
		DeleteDC(hdc);

		BITMAP bitmapSize;
		bmp->GetBitmap(&bitmapSize);

		InitializeRectByBITMAP(bitmapSize);

		surfaceID.push_back(CDDraw::RegisterBitmapWithHBITMAP(hbitmap));
		isBitmapLoaded = true;

		bmp->DeleteObject();
	}
	
	//! ¢FX??????¢FD??????C
	/*!
		@deprecated ??q v1.0.0 ??¢FD??????¢FD??A¢FX??????¢FD????????b `OnShow()` ???¢FG?I¢FDs `ShowBitmap()` ?¡ÓY¢FDi
		\sa ShowBitmap()
	*/
	void CMovingBitmap::UnshowBitmap()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before SetTopLeft() is called !!!");
		isAnimation = false;
		this->ShowBitmap(0);
	}

	//! ?]?m???????e¢FD????w?y???W?C
	/*!
		??N?P|?¡Ó?????¢FD??W???]?m?????w?y???W?C
		\param x ¢FD??W?? x ?y??
		\param y ¢FD??W?? y ?y??
	*/
	void CMovingBitmap::SetTopLeft(int x, int y)
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before SetTopLeft() is called !!!");

		for (int i = 0; i < int(locations.size()); i++) {
			int dx = locations[i].left - x;
			int dy = locations[i].top - y;
			locations[i].left = x;
			locations[i].top = y;
			locations[i].right -= dx;
			locations[i].bottom -= dy;
		}
	}

	//! ?]?m?????O?¡Ó_?¢FX¢FX??e?C
	/*!
		?Y CMovingBitmap ???J?h???????A?h¢FDi¢FDH??¢FD??????????]?w??¢FD??¢FX¢FX??e?C
		\param delay ¢FX??e?????????]¢FDH?@???¢FX?????^
		\param once ¢FX??e?O?¡Ó_?¢FX?@????¢FX??e?A?Y?O?h???n¢FDH `ToggleAnimation()` ???I¢FDs¢FX??e???¢FX??C
		\sa ToggleAnimation()
	*/
	void CMovingBitmap::SetAnimation(int delay, bool once) {
		if(!once) isAnimation = true;
		isOnce = once;
		delayCount = delay;
	}
	
	//! ??¢FD??????C
	/*!
		?????b `onShow()` ???I¢FDs?A¢FDB???????n?Q?????C
	*/
	void CMovingBitmap::ShowBitmap()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before ShowBitmap() is called !!!");
		CDDraw::BltBitmapToBack(surfaceID[frameIndex], locations[frameIndex].left, locations[frameIndex].top);
		ShowBitmapBySetting();
	}

	//! ??¢FD??????C
	/*!
		?????b `onShow()` ???I¢FDs?A¢FDB???????n?Q?????C
		\param factor ???j???v?A???n VGA ??¢FDd???????A?¡Ó_?h?P|????o??¡Ó??`?C?C
	*/
	void CMovingBitmap::ShowBitmap(double factor)
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before ShowBitmap() is called !!!");
		CDDraw::BltBitmapToBack(surfaceID[frameIndex], locations[frameIndex].left, locations[frameIndex].top, factor);
		ShowBitmapBySetting();
	}

	//! ?]?m?P??e??????¢FD??V?????????C
	/*!
		??????¢FD??V????????¢FDH 0 ?}?l?C
		\param frameIndex ??????¢FD??V?????????C
	*/
	void CMovingBitmap::SetFrameIndexOfBitmap(int frameIndex) {
		GAME_ASSERT(frameIndex < (int) surfaceID.size(), "??????????????¢FDX??");
		this->frameIndex = frameIndex;
	}

	//! ????o?P??e??????¢FD??V?????????C
	/*!
		\return ??????¢FD??V?????????C
	*/
	int CMovingBitmap::GetFrameIndexOfBitmap() {
		return frameIndex;
	}

	//! ????o?P??e????¢FD??W?? y ?b???y?????C
	/*!
		\return ????¢FD??W?? y ?b???y?????C
	*/
	int CMovingBitmap::GetTop()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before Top() is called !!!");
		return locations[frameIndex].top;
	}

	//! ????o?P??e?????e????C
	/*!
		\return ????o?P??e?????e????C
	*/
	int CMovingBitmap::GetWidth()
	{
		GAME_ASSERT(isBitmapLoaded, "A bitmap must be loaded before Width() is called !!!");
		return locations[frameIndex].right - locations[frameIndex].left;
	}
	
	//! ???¢FX?????¢FX??e?C
	/*!
		??N¢FX??e?]?¢FX???l?V?A??¢FDB???l??????¢FX??e??¢FX??????C
	*/
	void CMovingBitmap::ToggleAnimation() {
		frameIndex = 0;
		isAnimation = true;
		isAnimationDone = false;
	}

	//! ??¢FD??O?¡Ó_?¢FX¢FX??e??¢FD??C
	/*!
		\return ¢FD??L???A??¢FD???¢FD??O?¡Ó_?¢FX¢FX??e??¢FD??C
	*/
	bool CMovingBitmap::IsAnimation() {
		return isAnimation;
	}

	//! ¢FX??e??¢FD??O?¡Ó_?w¢FX????¡Ó?¢FX??e?C
	/*!
		\return ¢FD??L???A??¢FD?¢FX??e??¢FD??O?¡Ó_?w¢FX????¡Ó?¢FX??e?C
	*/
	bool CMovingBitmap::IsAnimationDone() {
		return isAnimationDone;
	}

	//! ¢FX??e??¢FD??O?¡Ó_?¢FX????¢FX??e??¢FD??C
	/*!
		\return ¢FD??L???A??¢FD?¢FX??e??¢FD??O?¡Ó_?¢FX????¢FX??e??¢FD??C
	*/
	bool CMovingBitmap::IsOnceAnimation() {
		return isOnce;
	}

	//! ??¢FD??O?¡Ó_?w?????I¢FX}???C
	/*!
		\return ¢FD??L???A??¢FD???¢FD??O?¡Ó_?w?????I¢FX}???C
	*/
	bool CMovingBitmap::IsBitmapLoaded() {
		return isBitmapLoaded;
	}

	//! ?^????¢FD????V???C
	/*!
		\return ?^????¢FD????V???C
	*/
	int CMovingBitmap::GetFrameSizeOfBitmap() {
		return (int) surfaceID.size();
	}

	//! ???? BITMAP ?????l?? CMovingBitmap ???? location ??¢FD??C
	/*!
		\param bitmapSize ?w???l???L?? BITMAP ??¢FD??A??a???I¢FX}????¢FX??P?e
	*/
	void CMovingBitmap::InitializeRectByBITMAP(BITMAP bitmapSize) {
		const unsigned NX = 0;
		const unsigned NY = 0;
		CRect newCrect;
		newCrect.left = NX;
		newCrect.top = NY;
		newCrect.right = NX + bitmapSize.bmWidth;
		newCrect.bottom = NY + bitmapSize.bmHeight;
		locations.push_back(newCrect);
	}

	//! ??????¢FD????]?w??¢FX???????¢FD??????C
	void CMovingBitmap::ShowBitmapBySetting() {
		if (isAnimation == true && clock() - last_time >= delayCount) {
			frameIndex += 1;
			last_time = clock();
			if (frameIndex == surfaceID.size() && animationCount > 0) {
				animationCount -= 1;
			}
			if (frameIndex == surfaceID.size() && (isOnce || animationCount == 0)) {
				isAnimation = false;
				isAnimationDone = true;
				frameIndex = surfaceID.size() - 1;
				return;
			}
			frameIndex = frameIndex % surfaceID.size();
		}
	}

	//! ????o??¢FD????J?????W???C
	/*!
		\return ?^???????W???A?Y?????|¢FD????J?A?h?^???@???r???C
	*/
	string CMovingBitmap::GetImageFileName() {
		return imageFileName;
	}

	//! ????o??¢FD??L?o?C???C
	/*!
		\return ?^???L?o?C???A?Y??¢FD?¢FD??]?w?L?o?C???A?^?? `CLR_INVALID`?C
	*/
	COLORREF CMovingBitmap::GetFilterColor() {
		return filterColor;
	}

	//! ????¢FD??O?¡Ó_¢FD??|?C
	/*!
		\param bmp1 ???@?? CMovingBitmap ??¢FD?
		\param bmp2 ???G?? CMovingBitmap ??¢FD?
		\return ?^??¢FD??L???A¢FDN??????¢FD??O?¡Ó_¢FD??|?C
	*/
	bool CMovingBitmap::IsOverlap(CMovingBitmap bmp1, CMovingBitmap bmp2) {
		CRect rect;
		BOOL isOverlap = rect.IntersectRect(bmp1.locations[bmp1.GetFrameIndexOfBitmap()], bmp2.locations[bmp2.GetFrameIndexOfBitmap()]);
		return isOverlap;
	}

	/////////////////////////////////////////////////////////////////////////////
	// CTextDraw: The class provide the ability to draw the text.
	// ?o?? class ?¢FG?????r???¡Óe?{
	// ?n????o?????I¢FDs(?B¢FD?)???U?????O?A???O¢FDi¢FDH?¢FG???U?C???{???O?¢FX???PN??
	/////////////////////////////////////////////////////////////////////////////

	//! ?b?e????W?L¢FDX???r?C
	/*!
		?¡Ó?????N pDC ????o???d¢FD?¢FD??? caller?A?¡ÓA¢FD???P?n????o?P??e?? pDC ?????A?M??¢FXO??o?????C
		\param pDC?A?@?? CDC ?????A¢FDi??¢FD? `CDDraw::GetBackCDC()` ????o?C
		\param x ???r??¢FD???¢FD??W?? x ?y??
		\param y ???r??¢FD???¢FD??W?? y ?y??
		\param str ?????¢FD??????r
	*/
	void CTextDraw::Print(CDC *pDC, int x, int y, string str) {
		x = CDDraw::IsFullScreen() ? x + (RESOLUTION_X - SIZE_X) / 2 : x;
		y = CDDraw::IsFullScreen() ? y + (RESOLUTION_Y - SIZE_Y) / 2 : y;
		pDC->TextOut(x, y, str.c_str());
	}

	//! ?]?w?P??e???r???????C
	/*!
		?¡Ó?????N pDC ????o???d¢FD?¢FD??? caller?A?¡ÓA¢FD???P?n????o?P??e?? pDC ?????A?M??¢FXO??o?????C
		???]?w?P|?b?]?w?? pDC ?????Q??????¢FD¢FF¢FDh?]?w???C
		\param pDC?A?@?? CDC ?????A¢FDi??¢FD? `CDDraw::GetBackCDC()` ????o?C
		\param size ???r???j?p?]¢FDH pt ?¢FX?????A???]?¡Ó??N?????A???¢FG?@?w?P|?¡Ó?¢FD????X pt ?¢FX???????j?p?^
		\param fontName ?r???W??
		\param fontColor ?r???C??
		\param weight ?r????????]?w?]?¢FX 500?^
	*/
	void CTextDraw::ChangeFontLog(CDC *pDC, int size, string fontName, COLORREF fontColor, int weight) {
		CFont* fp;

		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(fontColor);
		LOGFONT lf;
		CFont f;
		memset(&lf, 0, sizeof(lf));
		lf.lfHeight = -MulDiv(size, GetDeviceCaps(pDC->GetSafeHdc(), LOGPIXELSY), 96);
		lf.lfWeight = weight;
		strcpy(lf.lfFaceName, fontName.c_str());
		f.CreateFontIndirect(&lf);
		fp = pDC->SelectObject(&f);
	}

}         
